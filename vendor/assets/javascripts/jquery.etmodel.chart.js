// Generated by CoffeeScript 1.3.3
(function() {
  var root,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  root = typeof global !== "undefined" && global !== null ? global : window;

  root.Chart = (function() {

    function Chart(options) {
      var view_class;
      if (options == null) {
        options = {};
      }
      this.refresh = __bind(this.refresh, this);

      this.gqueries = __bind(this.gqueries, this);

      if (options instanceof Element) {
        this.container = $(options);
        this._gqueries = this.container.data('etm-series').split(',');
        this.type = this.container.data('etm-chart');
      } else {
        this._gqueries = options.series;
        this.type = options.type;
      }
      this._gqueries = this._gqueries || [];
      view_class = (function() {
        switch (this.type) {
          case 'stacked_bar':
            return StackedBarChart;
          case 'bezier':
            return BezierChart;
        }
      }).call(this);
      if (!view_class) {
        throw "Unsupported chart type";
      }
      this.view = new view_class(this.container[0], this._gqueries);
    }

    Chart.prototype.gqueries = function() {
      return this._gqueries;
    };

    Chart.prototype.refresh = function(results) {
      return this.view.refresh(results);
    };

    return Chart;

  })();

  root.BaseChart = (function() {

    function BaseChart(container, gqueries) {
      this.tallest_column_value = __bind(this.tallest_column_value, this);
      this.container = container;
      this.gqueries = gqueries;
    }

    BaseChart.prototype.flatten = function(arr) {
      return $.map(arr, function(x) {
        return x;
      });
    };

    BaseChart.prototype.tallest_column_value = function(data) {
      var future, g, present, _i, _len, _ref;
      present = future = 0;
      _ref = this.gqueries;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        g = _ref[_i];
        present += data.results[g].present;
        future += data.results[g].future;
      }
      return Math.max(present, future);
    };

    return BaseChart;

  })();

}).call(this);
